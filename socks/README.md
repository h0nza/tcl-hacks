## Simple socks5 proxy for tampering with TCP

I recommend using this with redsocks:  http://darkk.net.ru/redsocks

## redsocks/iptables setup

Consider the goal:

  * given a target machine `192.168.122.121`, we want to tamper with some traffic sent to it in order to exercise flaws or boundary conditions
  * it's easier to tamper with well-formed traffic generated by a program or library than to read enough RFCs to write our own implementation of the protocol
  * to avoid profusion of VMs and a complex orchestrated setup, we'd rather do this all in one host

Enter `redsocks`.  With `iptables`, `redsocks` is able to *transparently* forward selected traffic through a SOCKS5 proxy.  We can be selective about what traffic is forwarded through either standard IP/TCP layer rules or using fancy capabilities such as `-m owner`.

To make it all work in one host, we need to ensure that the proxy's own traffic will not be transparently proxied.  `-m owner` comes in particularly handy for this.


### Build redsocks

You will need `libevent-devel`, then just type `make`:

    sudo dnf -y install libevent-devel
    git checkout https://github.com/darkk/redsocks
    cd redsocks
    make


### Configure redsocks

Take the standard config and adjust only `ip =` and `port =` lines to point where `socks5.tcl` will be running:

    cp redsocks.conf.example redsocks.conf
    vi redsocks.conf

    ip = localhost;
    port = 1080;


### Sysadmin magic

Add a group for the proxy to run under:

    groupadd mysocks

If you know how to play with `firewalld`, do that.  If not, disable the jerk and insert some rules like the following:

    iptables -t nat -N REDSOCKS

    # don't mess with local traffic
    iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN
    iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
    # don't mess with proxy traffic
    iptables -t nat -A REDSOCKS -m owner --gid-owner mysocks -j RETURN

    iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345

Now create a rule or rules to send the traffic you want through the proxy.

All traffic:

    iptables -t nat -A OUTPUT -p tcp -j REDSOCKS

Traffic to a particular dest:

    iptables -t nat -A OUTPUT -p tcp -d 192.168.122.121 -j REDSOCKS

Traffic from processes belonging to a particular gid:

    iptables -t nat -A OUTPUT -p tcp -m owner --gid-owner socksified -j REDSOCKS

## Configure socks5.tcl

Edit the `write` procs in `tamper_up` (client->server) and `tamper_down` (sever->client).  `return $data` is the empty tamper which does nothing.


## Run everything

Run redsocks as any user you like:

    ./redsocks

And socks5.tcl *as gid mysocks*:

    sg mysocks tclsh socks5.tcl

Watch the logs and enjoy as you do your tampering.  So much fun!


## Going Further

Making this truly transparent (source port too) would be cool, but that requires getting routing infrastructure involved .. probably easiest on a vm acting as a router using `IP_TRANSPARENT` (see ip(7) and redsocks/doc/balabit-TPROXY-README.txt), which requires `CAP_NET_ADMIN`.

Note that NFQUEUE userspace filters can not edit packets, only delay them and make routing decisions.

Doing this fast in C would be relatively easy.  A decent architecture would be able to stream pcap output, and take commands on a socket to set up *simple* re-writes.
